{"version":3,"sources":["atob/index.js","btoa/index.js","index.js"],"names":["atob","data","replace","length","test","output","buffer","accumulatedBits","i","atobLookup","String","fromCharCode","chr","charCodeAt","btoa","s","out","groupsOfSix","undefined","j","btoaLookup","idx"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["/**\n * Implementation of atob() according to the HTML and Infra specs, except that\n * instead of throwing INVALID_CHARACTER_ERR we return null.\n */\nexport function atob(data) {\n  // Web IDL requires DOMStrings to just be converted using ECMAScript\n  // ToString, which in our case amounts to using a template literal.\n  data = `${data}`;\n  // \"Remove all ASCII whitespace from data.\"\n  data = data.replace(/[ \\t\\n\\f\\r]/g, \"\");\n  // \"If data's length divides by 4 leaving no remainder, then: if data ends\n  // with one or two U+003D (=) code points, then remove them from data.\"\n  if (data.length % 4 === 0) {\n    data = data.replace(/==?$/, \"\");\n  }\n  // \"If data's length divides by 4 leaving a remainder of 1, then return\n  // failure.\"\n  //\n  // \"If data contains a code point that is not one of\n  //\n  // U+002B (+)\n  // U+002F (/)\n  // ASCII alphanumeric\n  //\n  // then return failure.\"\n  if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {\n    return null;\n  }\n  // \"Let output be an empty byte sequence.\"\n  let output = \"\";\n  // \"Let buffer be an empty buffer that can have bits appended to it.\"\n  //\n  // We append bits via left-shift and or.  accumulatedBits is used to track\n  // when we've gotten to 24 bits.\n  let buffer = 0;\n  let accumulatedBits = 0;\n  // \"Let position be a position variable for data, initially pointing at the\n  // start of data.\"\n  //\n  // \"While position does not point past the end of data:\"\n  for (let i = 0; i < data.length; i++) {\n    // \"Find the code point pointed to by position in the second column of\n    // Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in\n    // the first cell of the same row.\n    //\n    // \"Append to buffer the six bits corresponding to n, most significant bit\n    // first.\"\n    //\n    // atobLookup() implements the table from RFC 4648.\n    buffer <<= 6;\n    buffer |= atobLookup(data[i]);\n    accumulatedBits += 6;\n    // \"If buffer has accumulated 24 bits, interpret them as three 8-bit\n    // big-endian numbers. Append three bytes with values equal to those\n    // numbers to output, in the same order, and then empty buffer.\"\n    if (accumulatedBits === 24) {\n      output += String.fromCharCode((buffer & 0xff0000) >> 16);\n      output += String.fromCharCode((buffer & 0xff00) >> 8);\n      output += String.fromCharCode(buffer & 0xff);\n      buffer = accumulatedBits = 0;\n    }\n    // \"Advance position by 1.\"\n  }\n  // \"If buffer is not empty, it contains either 12 or 18 bits. If it contains\n  // 12 bits, then discard the last four and interpret the remaining eight as\n  // an 8-bit big-endian number. If it contains 18 bits, then discard the last\n  // two and interpret the remaining 16 as two 8-bit big-endian numbers. Append\n  // the one or two bytes with values equal to those one or two numbers to\n  // output, in the same order.\"\n  if (accumulatedBits === 12) {\n    buffer >>= 4;\n    output += String.fromCharCode(buffer);\n  } else if (accumulatedBits === 18) {\n    buffer >>= 2;\n    output += String.fromCharCode((buffer & 0xff00) >> 8);\n    output += String.fromCharCode(buffer & 0xff);\n  }\n  // \"Return output.\"\n  return output;\n}\n/**\n * A lookup table for atob(), which converts an ASCII character to the\n * corresponding six-bit number.\n */\nfunction atobLookup(chr) {\n  if (/[A-Z]/.test(chr)) {\n    return chr.charCodeAt(0) - \"A\".charCodeAt(0);\n  }\n  if (/[a-z]/.test(chr)) {\n    return chr.charCodeAt(0) - \"a\".charCodeAt(0) + 26;\n  }\n  if (/[0-9]/.test(chr)) {\n    return chr.charCodeAt(0) - \"0\".charCodeAt(0) + 52;\n  }\n  if (chr === \"+\") {\n    return 62;\n  }\n  if (chr === \"/\") {\n    return 63;\n  }\n  // Throw exception; should not be hit in tests\n  return undefined;\n}\n\n","/**\n * btoa() as defined by the HTML and Infra specs, which mostly just references\n * RFC 4648.\n */\nexport function btoa(s) {\n  let i;\n  // String conversion as required by Web IDL.\n  s = `${s}`;\n  // \"The btoa() method must throw an \"InvalidCharacterError\" DOMException if\n  // data contains any character whose code point is greater than U+00FF.\"\n  for (i = 0; i < s.length; i++) {\n    if (s.charCodeAt(i) > 255) {\n      return null;\n    }\n  }\n  let out = \"\";\n  for (i = 0; i < s.length; i += 3) {\n    const groupsOfSix = [undefined, undefined, undefined, undefined];\n    groupsOfSix[0] = s.charCodeAt(i) >> 2;\n    groupsOfSix[1] = (s.charCodeAt(i) & 0x03) << 4;\n    if (s.length > i + 1) {\n      groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;\n      groupsOfSix[2] = (s.charCodeAt(i + 1) & 0x0f) << 2;\n    }\n    if (s.length > i + 2) {\n      groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;\n      groupsOfSix[3] = s.charCodeAt(i + 2) & 0x3f;\n    }\n    for (let j = 0; j < groupsOfSix.length; j++) {\n      if (typeof groupsOfSix[j] === \"undefined\") {\n        out += \"=\";\n      } else {\n        out += btoaLookup(groupsOfSix[j]);\n      }\n    }\n  }\n  return out;\n}\n\n/**\n * Lookup table for btoa(), which converts a six-bit number into the\n * corresponding ASCII character.\n */\nfunction btoaLookup(idx) {\n  if (idx < 26) {\n    return String.fromCharCode(idx + \"A\".charCodeAt(0));\n  }\n  if (idx < 52) {\n    return String.fromCharCode(idx - 26 + \"a\".charCodeAt(0));\n  }\n  if (idx < 62) {\n    return String.fromCharCode(idx - 52 + \"0\".charCodeAt(0));\n  }\n  if (idx === 62) {\n    return \"+\";\n  }\n  if (idx === 63) {\n    return \"/\";\n  }\n  // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the tests.\n  return undefined;\n}\n","export * from './atob'\nexport * from './btoa'\n"]}